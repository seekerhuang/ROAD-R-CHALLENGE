'''
This code is used to integrate model results with different nms parameters (0.60, 0.55, 0.50, 0.45, 0.42) and seq_len (140、120、100、80、70、40) based on the iou threshold. 
Due to the ranking of the generated files based on confidence scores, we adopt a strategy where the IOU threshold decreases as the confidence score decreases. 
This ensures that while maintaining a high recall rate, we minimize redundant detections as much as possible.
Please note that this code should be used on the pkl files generated by the 'ensemble_ds_onlydino_first.py' code, not on the original pkl files.
'''




import pickle
import numpy as np
from collections import defaultdict
from itertools import product
from tqdm import tqdm

# read the pkl file generated by the 'ensemble_ds_onlydino_first.py' code
with open('./last_middle/res/final_pred_detections-20-140-45_test_50.pkl', 'rb') as f:
    initial_data = pickle.load(f)

# define a function to compute iou

def compute_iou(box, box2):
    xmin = max(box[0], box2[0])
    ymin = max(box[1], box2[1]) 
    xmax = min(box[2], box2[2])
    ymax = min(box[3], box2[3])

    iw = np.maximum(xmax - xmin, 0.) 
    ih = np.maximum(ymax - ymin, 0.)
    
    if iw > 0 and ih > 0:
        intsc = iw*ih 
    else:
        intsc = 0.0
        
    union = (box2[2] - box2[0]) * (box2[3] - box2[1]) + \
           (box[2] - box[0]) * (box[3] - box[1]) - intsc 
           
    iou = intsc/union
    return iou


# define a function to perform nms
def nms(bboxes, iou_threshold):
    if len(bboxes) == 0:
        return []
    bboxes = sorted(bboxes, key=lambda x: x[4], reverse=True)
    keep = []
    while len(bboxes) > 0:
        keep.append(bboxes[0])
        if len(bboxes) == 1:
            break
        ious = [compute_iou(keep[-1][:4], bboxes[i][:4]) for i in range(1, len(bboxes))]
        idx = np.where(np.array(ious) <= iou_threshold)[0]
        bboxes = [bboxes[i + 1] for i in idx]
    return keep

# define a function to add bbox to pkl file
def add_bbox_to_pkl(data, video_name, frame_name, bbox):
    # if video_name not in data:
    #     data[video_name] = {}
    # if frame_name not in data[video_name]:
    #     data[video_name][frame_name] = []
    data[video_name][frame_name].append(bbox)

# define a function to compare pkl files
def compare_pkl_files(initial_data, pkl_file_path):
    with open(pkl_file_path, 'rb') as f:
        data = pickle.load(f)
    for video_name, frames in tqdm(data.items()):
        for frame_name, bboxes in frames.items():
            if not bboxes:
                continue
            
            if not initial_data[video_name][frame_name]:
                for bbox in bboxes:
                    add_bbox_to_pkl(initial_data, video_name, frame_name, bbox)
            elif len(initial_data[video_name][frame_name]) <= 30:
                new_bboxes = []
               
                if len(bboxes)>0:
                    if len(bboxes)==1:
                        overlaps = [compute_iou(bboxes[0]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                        if max(overlaps) < 0.40:
                            if len(bboxes[0])>0:
                                add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[0])
                    elif len(bboxes)==2:
                        for tt in range(0,len(bboxes)):
                            # print("bbox",bbox)
                            overlaps = [compute_iou(bboxes[tt]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                            if max(overlaps) < 0.39:
                                # new_bboxes.append(bbox)
                                if len(bboxes[tt])>0:
                                    add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[tt])
                    elif len(bboxes)==3:
                        for tt in range(0,len(bboxes)):
                            # print("bbox",bbox)
                            overlaps = [compute_iou(bboxes[tt]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                            if max(overlaps) < 0.38:
                                # new_bboxes.append(bbox)
                                if len(bboxes[tt])>0:
                                    add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[tt])
                    elif len(bboxes)==4:
                        for tt in range(0,len(bboxes)):
                            # print("bbox",bbox)
                            overlaps = [compute_iou(bboxes[tt]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                            if max(overlaps) < 0.38:
                                # new_bboxes.append(bbox)
                                if len(bboxes[tt])>0:
                                    add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[tt])
                    elif len(bboxes)==5:
                        for tt in range(0,len(bboxes)):
                            # print("bbox",bbox)
                            overlaps = [compute_iou(bboxes[tt]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                            if max(overlaps) < 0.38:
                                # new_bboxes.append(bbox)
                                if len(bboxes[tt])>0:
                                    add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[tt])
                    elif len(bboxes)==6:
                        for tt in range(0,len(bboxes)):
                            # print("bbox",bbox)
                            overlaps = [compute_iou(bboxes[tt]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                            if max(overlaps) < 0.38:
                                # new_bboxes.append(bbox)
                                if len(bboxes[tt])>0:
                                    add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[tt])
                    elif len(bboxes)>=7:
                        for tt in range(0,6):
                            # print("bbox",bbox)
                            overlaps = [compute_iou(bboxes[tt]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                            if max(overlaps) < 0.37:
                                # new_bboxes.append(bbox)
                                if len(bboxes[tt])>0:
                                    add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[tt])
                    # for tt in range(0,len(bboxes)):
                    #     # print("bbox",bbox)
                    #     overlaps = [compute_iou(bboxes[tt]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                    # # overlaps = [compute_iou(bboxes[0]['bbox'], initial_bbox['bbox']) for initial_bbox in initial_data[video_name][frame_name]]
                    #     if max(overlaps) < 0.5:
                    #         # new_bboxes.append(bbox)
                    #         if len(bboxes[tt])>0:
                    #             add_bbox_to_pkl(initial_data, video_name, frame_name, bboxes[tt])
                    # break
                # if len(new_bboxes) > 0:
                #     initial_data[video_name][frame_name].extend(new_bboxes)
                    # break
                else:
                    continue
            else:
                continue
            # initial_data[video_name][frame_name] = nms(initial_data[video_name][frame_name], 0.5)
    return initial_data




pkl_file_paths = [
        'your_pkl_file_path',
]









for pkl_file_path in pkl_file_paths:
    initial_data = compare_pkl_files(initial_data, pkl_file_path)
    is_empty = False
    is_over_limit = True
    for video_name, frames in initial_data.items():
        for frame_name, bboxes in frames.items():
            if len(bboxes) == 0:
                is_empty = True
            if len(bboxes) <= 20:
                is_over_limit = False
    if ( (not is_empty) and is_over_limit ):
        break


with open('./res/final_ens_4_t1_140_120_100_80_70_len7_all6.pkl', 'wb') as f:
    pickle.dump(initial_data, f)
   